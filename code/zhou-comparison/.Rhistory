GeminiError = norm(invA - (GeminiEstimate/tr(GeminiEstimate)),"F")^2 / normA
results$Gemini[j] = results$Gemini[j]+ GeminiError/(NumInstances*TrialsPerInstance)
#operator error
OpGeminiError = norm(invA - (GeminiEstimate/tr(GeminiEstimate)),"I")^2
OpResults$Gemini[j] = OpResults$Gemini[j]+ OpGeminiError/(NumInstances*TrialsPerInstance)
#calculate geodesic error
GeoGeminiError = GeodesicDistance(DetNorm(invA), DetNorm(GeminiEstimate))^2/GeoTrivialError^2
GeoResults$Gemini[j] = GeoResults$Gemini[j] + GeoGeminiError/(NumInstances*TrialsPerInstance)
#regularized Sinkhorn
#set sinkhorn penalties
RegSinkFactor = 10
tic("regularized sinkhorn")
RegSinkEstimate = regsinkhorn(X,tol = .1*Regularizers[j], reg = Regularizers[j]*RegSinkFactor)[[1]]
toc()
#calculate frobenius
RegSinkError = norm(invA - (RegSinkEstimate/tr(RegSinkEstimate)),"F")^2 / normA
results$RegSink[j] = results$RegSink[j]+ RegSinkError/(NumInstances*TrialsPerInstance)
#operator error
OpSinkError = norm(invA - (RegSinkEstimate/tr(RegSinkEstimate)),"I")^2
OpResults$RegSink[j] = OpResults$RegSink[j]+ OpSinkError/(NumInstances*TrialsPerInstance)
#geodesic distance
GeoSinkError = GeodesicDistance(DetNorm(invA), DetNorm(RegSinkEstimate))^2/GeoTrivialError^2
GeoResults$RegSink[j] = GeoResults$RegSink[j] + GeoSinkError/(NumInstances*TrialsPerInstance)
}
}
}
output<- list(Results = results,OpResults = OpResults, GeoResults = GeoResults)
}
SimplePlot <- function(results){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ mytheme
return(lp)}
ans = SpikedComparison(25,50,1,RegMin=-10,RegMax = 5,NumInstances =2, TrialsPerInstance  = 2, RegStride = .5)
SimplePlot(ans$GeoResults)
lp = SimplePlot(ans$GeoResults)
lp
pdf("plot.pdf")
SimplePlot(ans$GeoResults)
def.off())
pdf("plot.pdf")
SimplePlot(ans$GeoResults)
def.off()
pdf("plot.pdf")
SimplePlot(ans$GeoResults)
dev.off()
ans = SpikedComparison(25,50,1,RegMin=-10,RegMax = 5,NumInstances =2, TrialsPerInstance  = 2, RegStride = .5)
pdf("plot.pdf")
lp = SimplePlot(ans$GeoResults)
dev.off()
lp
lp = SimplePlot(ans$GeoResults)
lp
#devtools::install_github("EcoForecast/ecoforecastR")
#library(ecoforecastR)
source("/Users/niabartolucci/Dropbox/My Mac (Niaâ€™s MacBook Pro)/Desktop/Classes Spring 2021/Ecological Forecasting/ecoforecastR/R/utils.R")
ans = SpikedComparison(25,50,1,RegMin=-10,RegMax = 5,NumInstances =2, TrialsPerInstance  = 2, RegStride = .5)
pdf("plot.pdf")
lp = SimplePlot(ans$GeoResults)
dev.off()
lp
lp = SimplePlot(ans$GeoResults)
pdf("plot.pdf")
lp
dev.off()
lp
SimplePlot <- function(results){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ mytheme + labs(title="Error in geodesic distance")
return(lp)}
ans = SpikedComparison(25,50,1,RegMin=-10,RegMax = 5,NumInstances =2, TrialsPerInstance  = 2, RegStride = .5)
lp = SimplePlot(ans$GeoResults)
pdf("plot.pdf")
lp
dev.off()
lp
DetNorm <-function(A){
n = dim(A)[1]
return(A*det(A)^(-1/n))
}
#define geodesic distance
GeodesicDistance <-function(P,Q){
root = solve(sqrtm(Q))
P = root %*% P %*% root
return(norm(logm(P),"F"))
}
#test geodesic distance
#A = diag(c(1,2,3))
#A = expm(A)
#GeodesicDistance(diag(c(1,1,1)), A)
SpikedComparison <-function(SmallDimension,BigDimension,NumSamples,NumInstances=2,TrialsPerInstance=2,spike = 10, RegMin = -5, RegMax =5, RegStride=1){
Regularizers = exp(RegStride*c(floor(RegMin/RegStride):floor(RegMax/RegStride)))
print(Regularizers)
results = data.frame(Regularizer = Regularizers,Gemini=0,RegSink = 0,Trivial=0)
GeoResults = data.frame(Regularizer = Regularizers,Gemini=0,RegSink = 0,Trivial=0)
OpResults = data.frame(Regularizer = Regularizers,Gemini=0,RegSink = 0,Trivial=0)
for (j in 1:length(Regularizers)){
#for each value of the regularizer we will compute the error of the estimator on several ground truth covariances
for (l in 1:NumInstances){
#define the covariances
A = diag(SmallDimension)
v = matrix(rnorm(SmallDimension),nrow = SmallDimension, ncol = 1)
A = A + spike*v%*%t(v)
rootA = sqrtm(A)
invA = solve(A)
invA = invA/tr(invA)
normA = norm(invA,"F")^2
B = diag(BigDimension)
v = matrix(rnorm(BigDimension),nrow = BigDimension, ncol = 1)
B = B + spike*v%*%t(v)
rootB = sqrtm(B)
invB = solve(B)
#for each covariance we will compute the estimate with fresh samples from the model a few times
for(i in 1:TrialsPerInstance){
#create the fresh samples
X = list(0*c(1:NumSamples))
for(i in 1:NumSamples){
#create the data
X[[i]] = rootA%*%matrix(rnorm(SmallDimension*BigDimension,sd=1), nrow=SmallDimension, ncol=BigDimension)%*%rootB
}
#trivial frobenius error
TrivialError = norm(invA - diag(SmallDimension)/SmallDimension,"F")^2 / normA
results$Trivial[j] = results$Trivial[j]+ TrivialError/(NumInstances*TrialsPerInstance)
#operator error
OpTrivialError = norm(invA - diag(SmallDimension)/SmallDimension,"I")^2
OpResults$Trivial[j] = OpResults$Trivial[j]+ OpTrivialError/(NumInstances*TrialsPerInstance)
#geodesic trivial
GeoTrivialError = GeodesicDistance(DetNorm(invA), diag(SmallDimension))
#GeoResults$Trivial[j] = GeoResults$Trivial[j] + GeoTrivialError/(NumInstances*TrialsPerInstance)
GeoResults$Trivial[j] = GeoResults$Trivial[j] + 1/(NumInstances*TrialsPerInstance)
#gemini
#set gemini penalties
GeminiRegFactor = 1*sqrt(log(SmallDimension)/BigDimension)
tic("geminiB")
out <- GeminiBmult(X, GeminiRegFactor*Regularizers[j], penalize.diagonal=FALSE)
toc()
GeminiEstimate = out$B.hat.inv
#calculate frobenius error
GeminiError = norm(invA - (GeminiEstimate/tr(GeminiEstimate)),"F")^2 / normA
results$Gemini[j] = results$Gemini[j]+ GeminiError/(NumInstances*TrialsPerInstance)
#operator error
OpGeminiError = norm(invA - (GeminiEstimate/tr(GeminiEstimate)),"I")^2
OpResults$Gemini[j] = OpResults$Gemini[j]+ OpGeminiError/(NumInstances*TrialsPerInstance)
#calculate geodesic error
GeoGeminiError = GeodesicDistance(DetNorm(invA), DetNorm(GeminiEstimate))/GeoTrivialError
GeoResults$Gemini[j] = GeoResults$Gemini[j] + GeoGeminiError/(NumInstances*TrialsPerInstance)
#regularized Sinkhorn
#set sinkhorn penalties
RegSinkFactor = 10
tic("regularized sinkhorn")
RegSinkEstimate = regsinkhorn(X,tol = .1*Regularizers[j], reg = Regularizers[j]*RegSinkFactor)[[1]]
toc()
#calculate frobenius
RegSinkError = norm(invA - (RegSinkEstimate/tr(RegSinkEstimate)),"F")^2 / normA
results$RegSink[j] = results$RegSink[j]+ RegSinkError/(NumInstances*TrialsPerInstance)
#operator error
OpSinkError = norm(invA - (RegSinkEstimate/tr(RegSinkEstimate)),"I")^2
OpResults$RegSink[j] = OpResults$RegSink[j]+ OpSinkError/(NumInstances*TrialsPerInstance)
#geodesic distance
GeoSinkError = GeodesicDistance(DetNorm(invA), DetNorm(RegSinkEstimate))/GeoTrivialError
GeoResults$RegSink[j] = GeoResults$RegSink[j] + GeoSinkError/(NumInstances*TrialsPerInstance)
}
}
}
output<- list(Results = results,OpResults = OpResults, GeoResults = GeoResults)
}
SimplePlot <- function(results){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ mytheme + labs(title="Error in geodesic distance")
return(lp)}
ans = SpikedComparison(25,50,1,RegMin=-10,RegMax = 5,NumInstances =2, TrialsPerInstance  = 2, RegStride = .5)
lp = SimplePlot(ans$GeoResults)
pdf("plot.pdf")
lp
dev.off()
lp
SimplePlot <- function(results,title_text){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ mytheme + labs(title=title_text)
return(lp)}
#first, the runs.
ans = SpikedComparison(25,50,1,RegMin=-20,RegMax = 10,NumInstances =5, TrialsPerInstance  = 5, RegStride = .5)
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
GeoPlot
SimplePlot <- function(results,title_text){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = 10^(-.1*c(10:10)),labels = trans_format("log10", math_format(10^.x)))+ mytheme + labs(title=title_text)
return(lp)}
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
GeoPlot
SimplePlot <- function(results,title_text){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = 1.1^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ mytheme + labs(title=title_text)
return(lp)}
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
GeoPlot
SimplePlot <- function(results,title_text){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = .1*(-10:10),labels = trans_format("log10", math_format(10^.x)))+ mytheme + labs(title=title_text)
return(lp)}
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
GeoPlot
SimplePlot <- function(results,title_text){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = .1*(-10:10))+ mytheme + labs(title=title_text)
return(lp)}
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
GeoPlot
SimplePlot <- function(results,title_text){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = .1*(-10:20))+ mytheme + labs(title=title_text)
return(lp)}
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
GeoPlot
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance; $n=2$")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
GeoPlot
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
GeoPlot
DetNorm <-function(A){
n = dim(A)[1]
return(A*det(A)^(-1/n))
}
#define geodesic distance
GeodesicDistance <-function(P,Q){
root = solve(sqrtm(Q))
P = root %*% P %*% root
return(norm(logm(P),"F"))
}
#test geodesic distance
#A = diag(c(1,2,3))
#A = expm(A)
#GeodesicDistance(diag(c(1,1,1)), A)
SpikedComparison <-function(SmallDimension,BigDimension,NumSamples,NumInstances=2,TrialsPerInstance=2,spike = 10, RegMin = -5, RegMax =5, RegStride=1){
Regularizers = exp(RegStride*c(floor(RegMin/RegStride):floor(RegMax/RegStride)))
print(Regularizers)
results = data.frame(Regularizer = Regularizers,Gemini=0,RegSink = 0,Trivial=0, Simple=0)
GeoResults = data.frame(Regularizer = Regularizers,Gemini=0,RegSink = 0,Trivial=0, Simple=0)
OpResults = data.frame(Regularizer = Regularizers,Gemini=0,RegSink = 0,Trivial=0, Simple=0)
for (j in 1:length(Regularizers)){
#for each value of the regularizer we will compute the error of the estimator on several ground truth covariances
for (l in 1:NumInstances){
#define the covariances
A = diag(SmallDimension)
v = matrix(rnorm(SmallDimension),nrow = SmallDimension, ncol = 1)
A = A + spike*v%*%t(v)
rootA = sqrtm(A)
invA = solve(A)
invA = invA/tr(invA)
normA = norm(invA,"F")^2
B = diag(BigDimension)
v = matrix(rnorm(BigDimension),nrow = BigDimension, ncol = 1)
B = B + spike*v%*%t(v)
rootB = sqrtm(B)
invB = solve(B)
#for each covariance we will compute the estimate with fresh samples from the model a few times
for(i in 1:TrialsPerInstance){
#create the fresh samples
X = list(0*c(1:NumSamples))
for(i in 1:NumSamples){
#create the data
X[[i]] = rootA%*%matrix(rnorm(SmallDimension*BigDimension,sd=1), nrow=SmallDimension, ncol=BigDimension)%*%rootB
}
##################### Trivial
#trivial frobenius error
TrivialError = norm(invA - diag(SmallDimension)/SmallDimension,"F")^2 / normA
results$Trivial[j] = results$Trivial[j]+ TrivialError/(NumInstances*TrialsPerInstance)
#operator error
OpTrivialError = norm(invA - diag(SmallDimension)/SmallDimension,"I")^2
OpResults$Trivial[j] = OpResults$Trivial[j]+ OpTrivialError/(NumInstances*TrialsPerInstance)
#geodesic trivial
GeoTrivialError = GeodesicDistance(DetNorm(invA), diag(SmallDimension))
#GeoResults$Trivial[j] = GeoResults$Trivial[j] + GeoTrivialError/(NumInstances*TrialsPerInstance)
GeoResults$Trivial[j] = GeoResults$Trivial[j] + 1/(NumInstances*TrialsPerInstance)
##################### gemini
#set gemini penalties
GeminiRegFactor = 1*sqrt(log(SmallDimension)/BigDimension)
tic("geminiB")
out <- GeminiBmult(X, GeminiRegFactor*Regularizers[j], penalize.diagonal=FALSE)
toc()
GeminiEstimate = out$B.hat.inv
#calculate frobenius error
GeminiError = norm(invA - (GeminiEstimate/tr(GeminiEstimate)),"F")^2 / normA
results$Gemini[j] = results$Gemini[j]+ GeminiError/(NumInstances*TrialsPerInstance)
#operator error
OpGeminiError = norm(invA - (GeminiEstimate/tr(GeminiEstimate)),"I")^2
OpResults$Gemini[j] = OpResults$Gemini[j]+ OpGeminiError/(NumInstances*TrialsPerInstance)
#calculate geodesic error
GeoGeminiError = GeodesicDistance(DetNorm(invA), DetNorm(GeminiEstimate))/GeoTrivialError
GeoResults$Gemini[j] = GeoResults$Gemini[j] + GeoGeminiError/(NumInstances*TrialsPerInstance)
#############################regularized Sinkhorn
#set sinkhorn penalties
RegSinkFactor = 10
tic("regularized sinkhorn")
RegSinkEstimate = regsinkhorn(X,tol = .1*Regularizers[j], reg = Regularizers[j]*RegSinkFactor)[[1]]
toc()
#calculate frobenius
RegSinkError = norm(invA - (RegSinkEstimate/tr(RegSinkEstimate)),"F")^2 / normA
results$RegSink[j] = results$RegSink[j]+ RegSinkError/(NumInstances*TrialsPerInstance)
#operator error
OpSinkError = norm(invA - (RegSinkEstimate/tr(RegSinkEstimate)),"I")^2
OpResults$RegSink[j] = OpResults$RegSink[j]+ OpSinkError/(NumInstances*TrialsPerInstance)
#geodesic distance
GeoSinkError = GeodesicDistance(DetNorm(invA), DetNorm(RegSinkEstimate))/GeoTrivialError
GeoResults$RegSink[j] = GeoResults$RegSink[j] + GeoSinkError/(NumInstances*TrialsPerInstance)
########################### simple
#just take inverse of marginal
SimpleEst = cpmap(X,diag(BigDimension))
SimpleEst = solve(SimpleEst)
SimpleEst = DetNorm(SimpleEst)
#calculate frobenius
SimpleError = norm(invA - (SimpleEst/tr(SimpleEst)),"F")^2 / normA
results$Simple[j] = results$Simple[j]+ SimpleError/(NumInstances*TrialsPerInstance)
#operator error
OpSimpleError = norm(invA - (SimpleEst/tr(SimpleEst)),"I")^2
OpResults$Simple[j] = OpResults$Simple[j]+ OpSimpleError/(NumInstances*TrialsPerInstance)
#geodesic distance
GeoSimpleError = GeodesicDistance(DetNorm(invA), SimpleEst)/GeoTrivialError
GeoResults$Simple[j] = GeoResults$Simple[j] + GeoSimpleError/(NumInstances*TrialsPerInstance)
}
}
}
output<- list(Results = results,OpResults = OpResults, GeoResults = GeoResults)
}
SimplePlot <- function(results,title_text){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = .1*(-10:20))+ mytheme + labs(title=title_text)
return(lp)}
#a run with few
ans = SpikedComparison(25,50,1,RegMin=-20,RegMax = 10,NumInstances =2, TrialsPerInstance  = 2, RegStride = .5)
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
GeoPlot
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
SimplePlot <- function(results,title_text){
mytheme <- theme(legend.text = element_text(family = "Helvetica", size = rel(1)),
#legend.position = "top",
axis.title = element_text(family = "Helvetica", size = rel(1)),
axis.text = element_text(family = "Helvetica", size = rel(1)),
axis.line = element_line(size = 1,colour = "black"),
axis.ticks = element_line(colour="black",size = rel(1)),
panel.grid.major = element_line(colour="grey90",size = rel(0.5)),
panel.grid.minor = element_blank(),
panel.background = element_rect(fill = "grey98"),
legend.key = element_rect(fill = "grey98"),
legend.title = element_text(family = "Helvetica", size = rel(1)),
plot.title = element_text(face = "bold", size = rel(1.25),family = "Helvetica"))
df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm", value.name = "Error")
#df = melt(results, id.vars = "Regularizer",variable.name = "Algorithm")
lp <- ggplot(data=df, aes(x=Regularizer, y=Error, group=Algorithm, color=Algorithm)) + geom_line() + geom_point() + scale_x_log10(breaks = 10^(-10:10),labels = trans_format("log10", math_format(10^.x)))+ scale_y_log10(breaks = .1*(-10:20))+ mytheme + labs(title=title_text)
return(lp)}
#a run with many runs
ans = SpikedComparison(25,50,1,RegMin=-20,RegMax = 10,NumInstances =5, TrialsPerInstance  = 5, RegStride = .5)
GeoPlot = SimplePlot(ans$GeoResults,"Error in geodesic distance")
pdf("GeoPlot.pdf")
GeoPlot
dev.off()
GeoPlot
