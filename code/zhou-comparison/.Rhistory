#print("marginal before funnies")
#print(solve(marginal)[1:3,1:3])
marginal = solve(marginal)
#print(diag(marginal))
sds = diag(diag(marginal)^(-1/2))
#print("left")
#print(sds)
marginal = sds%*%marginal%*%sds
#print(round(marginal,2))
#print(marginal)
#print("after 2 corr")
#tic("thresholding")
left = solve(sds)%*%psdthresh(marginal,thr)%*%solve(sds)/m
#toc()
#print(left)
#print("left")
#print(round(m*left,2))
#print("marginal after funnies")
#print(left)
#compute right scaling
#print(cpdual(kraus,left))
marginal=regcpdual(kraus,left,reg)
#print(matrix.rank(marginal))
#print(solve(marginal)[1:3,1:3])
marginal = solve(marginal)
#print(marginal)
#print(diag(marginal))
sds = diag(diag(marginal)^(-1/2))
#print(sds)
#print("right")
marginal = sds%*%marginal%*%sds
#print(marginal)
right = (solve(sds))%*%psdthresh(marginal,thr)%*%(solve(sds))/n
#output the pair of them
list(left,right)
}
#regularized sinkhorn
regsinkhorn<-function(kraus, tol=10**(-6),maxit=100,verbose=FALSE,reg=0.1){
m = dim(kraus[[1]])[1]
n = dim(kraus[[1]])[2]
#initialize number of iterations to zero
it = 0
#start with the identity
left = diag(m)
right = diag(n)
#initialize eps to 1, something large
eps = 1
#while not scaled
while(eps > tol & it < maxit){
#measure progress
eps = tr(matrix.power(left %*% regcpmap(kraus,right,reg) - diag(m)/m, 2))
#do a sinkhorn step
left = regsinkstep(kraus,right,reg)[[1]]
right = regsinkstep(kraus,right,reg)[[2]]
if(verbose){
print(eps)
}
#increase iterations
it =it+1
}
list(left,right)
}
threshsinkhorn<-function(kraus, tol=10**(-2),maxit=20,verbose=FALSE,thr=0.5,reg=1){
m = dim(kraus[[1]])[1]
n = dim(kraus[[1]])[2]
#initialize number of iterations to zero
it = 0
#start with the identity
left = diag(m)
right = diag(n)
#initialize eps to 1, something large
eps = 1
#while not scaled
while(eps > tol & it < maxit){
#do a sinkhorn step
eps = tr(matrix.power(left %*% regcpmap(kraus,right,reg) - diag(m)/m, 2))
if(verbose){
print(eps)
}
left = threshsinkstep(kraus,right,thr,reg)[[1]]
#print(left[1:4,1:4])
right = threshsinkstep(kraus,right,thr,reg)[[2]]
#print(right[1:4,1:4])
#measure progress
#increase iterations
it =it+1
}
list(left,right)
}
sinkhornlast<-function(kraus, tol=10**(-6),maxit=100,verbose=FALSE,reg=0.1,thr=0.1){
m = dim(kraus[[1]])[1]
n = dim(kraus[[1]])[2]
#initialize number of iterations to zero
it = 0
#start with the identity
left = diag(m)
right = diag(n)
#initialize eps to 1, something large
eps = 1
#while not scaled
while(eps > tol & it < maxit){
#measure progress
eps = tr(matrix.power(left %*% regcpmap(kraus,right,reg) - diag(m)/m, 2))
#do a sinkhorn step
left = regsinkstep(kraus,right,reg)[[1]]
right = regsinkstep(kraus,right,reg)[[2]]
if(verbose){
print(eps)
}
#increase iterations
it =it+1
}
#only does left right now
sds = diag(diag(left)^(-1/2))
invsds = diag(diag(left))
#print("left")
#print(sds)
left = sds%*%left%*%sds
#print(round(marginal,2))
#print(marginal)
#print("after 2 corr")
#tic("thresholding")
left = invsds%*%psdthresh(left,thr)%*%invsds/m
list(left,right)
}
#how's glasso-ing the last step do?
glassosinkhorn<-function(kraus, tol=10**(-6),maxit=100,verbose=FALSE,reg=0.1,glassoreg=1){
m = dim(kraus[[1]])[1]
n = dim(kraus[[1]])[2]
#initialize number of iterations to zero
it = 0
#start with the identity
left = diag(m)
right = diag(n)
#initialize eps to 1, something large
eps = 1
#while not scaled
while(eps > tol & it < maxit){
#measure progress
eps = tr(matrix.power(left %*% regcpmap(kraus,right,reg) - diag(m)/m, 2))
#do a sinkhorn step
left = regsinkstep(kraus,right,reg)[[1]]
right = regsinkstep(kraus,right,reg)[[2]]
if(verbose){
print(eps)
}
#increase iterations
it =it+1
}
#only fixes left
marginal1 = solve(left)
sd.row <- sqrt(diag(marginal1))
inv.sd.row <- 1 / sd.row
Gamma.hat.B <- diag(inv.sd.row)%*%marginal1%*%diag(inv.sd.row)
glasso.B <- glasso::glasso(Gamma.hat.B, glassoreg,
penalize.diagonal=FALSE)
#B.hat <- t(t(glasso.B$w * sd.row) * sd.row) / m
left <- m * t(t(glasso.B$wi * inv.sd.row) * inv.sd.row)
list(left,right)
}
thresh<-function(x,tol){
m = dim(x)[1]
n = dim(x)[2]
for(i in 1:n){
for(j in 1:m){
#print(x[i,j])
if(abs(x[i,j])<tol){
x[i,j]=0
}
}
}
return(x)
}
psdthresh<-function(x,tol){
m = dim(x)[1]
n = dim(x)[2]
for(i in 2:n){
for(j in 1:(i-1)){
#print(x[i,j])
if(abs(x[i,j])<tol){
y = abs(x[i,j])
x[i,j]=0
x[i,i] = x[i,i]+y
x[j,j] = x[j,j]+y
x[j,i]=0
}
}
}
return(x)
}
zhouflop<-function(X,reg=what){
}
#' Estimate Row-Row Covariance Structure Using Gemini
#'
#' GeminiB estimates the row-row covariance, inverse covariance,
#' correlation, and inverse correlation matrices using Gemini.
#' For identifiability, the covariance factors A and B are scaled so
#' that A has trace m, where m is the number of columns of X,
#' A is the column-column covariance matrix, and B is the row-row
#' covariance matrix.
#'
#' @param kraus tuple of Data matrices, of dimensions n by m.
#' @param rowpen Glasso penalty parameter.
#' @param penalize.diagonal Logical value indicating whether to penalize the
#' off-diagonal entries of the correlation matrix.  Default is FALSE.
#' @return
#' \item{B.hat.inv}{estimated inverse covariance matrix.}
#' \item{A.hat.inv}{estimated inverse covariance matrix. }
#' @examples
#' n1 <- 5
#' n2 <- 5
#' n <- n1 + n2
#' m <- 20
#' X <- matrix(rnorm(n * m), nrow=n, ncol=m)
#' rowpen <- sqrt(log(m) / n)
#' out <- GeminiB(X, rowpen, penalize.diagonal=FALSE)
#' # Display the estimated correlation matrix rounded to two
#' # decimal places.
#' print(round(out$corr.B.hat, 2))
#' @export
GeminiBmult <- function (kraus, rowpen, penalize.diagonal=FALSE) {
n = nrow(kraus[[1]])
#print(n)
m = ncol(kraus[[1]])
#print(m)
marginal1 = cpmap(kraus,diag(m))
Gamma.hat.B <- stats::cov2cor(marginal1)
#tic("entering glasso")
glasso.B <- glasso::glasso(Gamma.hat.B, rowpen,
penalize.diagonal=penalize.diagonal)
#toc()
sd.row <- sqrt(diag(marginal1))
inv.sd.row <- 1 / sd.row
B.hat <- t(t(glasso.B$w * sd.row) * sd.row) / m
B.hat.inv <- m * t(t(glasso.B$wi * inv.sd.row) * inv.sd.row)
output <- list(corr.B.hat=glasso.B$w,
corr.B.hat.inv=glasso.B$wi,
B.hat=B.hat,
B.hat.inv=B.hat.inv)
}
GeminiBflop <- function (kraus, rowpenA, rowpenB, penalize.diagonal=FALSE) {
niter = length(rowpenA)
n = nrow(kraus[[1]])
#print(n)
m = ncol(kraus[[1]])
r = length(kraus)
#print(r)
marginal1 = cpmap(kraus,diag(m))
#marginal2 = cpdual(kraus,diag(n))
sd.row <- sqrt(diag(marginal1))
#sd.col <- sqrt(diag(marginal2))
inv.sd.row <- 1 / sd.row
#inv.sd.col <- 1 / sd.col
Binv2 = diag(n)
Ainv2 = diag(m)
for (i in 1:(niter-1)){
tic("marginal1")
marginal1 = cpmap(kraus,solve(Ainv2))/r*m
sd.row <- sqrt(diag(marginal1))
inv.sd.row <- 1 / sd.row
Gamma.hat.B <- diag(inv.sd.row)%*%marginal1%*%diag(inv.sd.row)
glasso.B <- glasso::glasso(Gamma.hat.B, rowpenA[i],
penalize.diagonal=penalize.diagonal)
#B.hat <- t(t(glasso.B$w * sd.row) * sd.row) / m
Binv2 <- m * t(t(glasso.B$wi * inv.sd.row) * inv.sd.row)
toc()
tic("marginal2")
marginal2 = cpdual(kraus,solve(Binv2))/r*n
sd.col <- sqrt(diag(marginal2))
inv.sd.col <- 1 / sd.col
Gamma.hat.A <- diag(inv.sd.col)%*%marginal2%*%diag(inv.sd.col)
glasso.A <- glasso::glasso(Gamma.hat.A, rowpenB[i],
penalize.diagonal=penalize.diagonal)
Ainv2 <- n * t(t(glasso.A$wi * inv.sd.col) * inv.sd.col)
toc()
}
marginal1 = cpmap(kraus,solve(Ainv2))/r*m
sd.row <- sqrt(diag(marginal1))
inv.sd.row <- 1 / sd.row
Gamma.hat.B <- diag(inv.sd.row)%*%marginal1%*%diag(inv.sd.row)
glasso.B <- glasso::glasso(Gamma.hat.B, rowpenA[i],
penalize.diagonal=penalize.diagonal)
#B.hat <- t(t(glasso.B$w * sd.row) * sd.row) / m
Binv2 <- m * t(t(glasso.B$wi * inv.sd.row) * inv.sd.row)
output <- list(A.hat.inv2=Ainv2,
B.hat.inv2=Binv2)
}
ans = SpikedComparison(10,10,2,RegMin=-2,RegMax = 2,NumInstances =1, TrialsPerInstance  = 1, RegStride = .5)
#making the plots even nicer
library(gridExtra)
lp1=SimplePlot(ans$GeoResults)
lp1 = lp1 + ggtitle("Error in Geodesic distance") #cool way to title on the fly :)
lp2=SimplePlot(ans$OpResults)
lp2 = lp2 + ggtitle("Error in operator norm")
lp3=SimplePlot(ans$Results)
lp3 = lp3 + ggtitle("Error in Frobenius norm")
p = grid.arrange(lp1,lp2,lp3,nrow=1)
p
#pdf("25-50-spiked-frob.pdf")
#lp
#dev.off()
#lp
knitr::opts_chunk$set(echo = TRUE)
library(reshape2)
library(scales)
library(jointMeanCov)
library(Matrix)
library(expm)
library(matrixcalc)
library(ggplot2)
library(tictoc)
library(R.matlab)
options(matlab="/Applications/MATLAB_R2020b.app/bin/matlab")
Matlab$startServer()
matlab <- Matlab()
isOpen <- open(matlab)
#Hello did this save
ans = SpikedComparison(10,10,2,RegMin=-2,RegMax = 2,NumInstances =1, TrialsPerInstance  = 1, RegStride = .5)
knitr::opts_chunk$set(echo = TRUE)
library(reshape2)
library(scales)
library(jointMeanCov)
library(Matrix)
library(expm)
library(matrixcalc)
library(ggplot2)
library(tictoc)
library(R.matlab)
options(matlab="/Applications/MATLAB_R2020b.app/bin/matlab")
Matlab$startServer()
matlab <- Matlab()
isOpen <- open(matlab)
#Hello did this save
setOption(matlab, "readResult/interval",30*6)
evaluate(matlab,"addpath('../KGlasso_code')")
knitr::opts_chunk$set(echo = TRUE)
library(reshape2)
library(scales)
library(jointMeanCov)
library(Matrix)
library(expm)
library(matrixcalc)
library(ggplot2)
library(tictoc)
library(R.matlab)
options(matlab="/Applications/MATLAB_R2020b.app/bin/matlab")
Matlab$startServer()
matlab <- Matlab()
isOpen <- open(matlab)
#Hello did this save
setOption(matlab, "readResult/interval",30*6)
evaluate(matlab,"addpath('../KGlasso_code')")
knitr::opts_chunk$set(echo = TRUE)
library(reshape2)
library(scales)
library(jointMeanCov)
library(Matrix)
library(expm)
library(matrixcalc)
library(ggplot2)
library(tictoc)
library(R.matlab)
options(matlab="/Applications/MATLAB_R2020b.app/bin/matlab")
Matlab$startServer()
matlab <- Matlab()
isOpen <- open(matlab)
#Hello did this save
knitr::opts_chunk$set(echo = TRUE)
library(reshape2)
library(scales)
library(jointMeanCov)
library(Matrix)
library(expm)
library(matrixcalc)
library(ggplot2)
library(tictoc)
library(R.matlab)
options(matlab="/Applications/MATLAB_R2020b.app/bin/matlab")
Matlab$startServer()
matlab <- Matlab()
isOpen <- open(matlab)
#Hello did this save
setOption(matlab, "readResult/interval",30*6)
evaluate(matlab,"addpath('../KGlasso_code')")
DetNorm <-function(A){
n = dim(A)[1]
return(A*det(A)^(-1/n))
}
#define geodesic distance
GeodesicDistance <-function(P,Q){
root = solve(sqrtm(Q))
P = root %*% P %*% root
return(norm(logm(P),"F"))
}
#test geodesic distance
#A = diag(c(1,2,3))
#A = expm(A)
#GeodesicDistance(diag(c(1,1,1)), A)
SpikedComparison <-function(SmallDimension,BigDimension,NumSamples,NumInstances=2,TrialsPerInstance=2,spike = 10, RegMin = -5, RegMax =5, RegStride=1){
Regularizers = exp(RegStride*c(floor(RegMin/RegStride):floor(RegMax/RegStride)))
print(Regularizers)
results = data.frame(Regularizer = Regularizers,Gemini=0,RegSink = 0,Trivial=0, KGlasso = 0)
#need to add the sample covariance back in :/
#make copies for the other error metrics.
GeoResults = data.frame(results)
OpResults = data.frame(results)
setVariable(matlab, NumSamples=NumSamples, SmallDimension=SmallDimension, BigDimension=BigDimension)
for (j in 1:length(Regularizers)){
#for each value of the regularizer we will compute the error of the estimator on several ground truth covariances
MatReg = (Regularizers[j])^(.1)
setVariable(matlab, MatReg = MatReg)
for (l in 1:NumInstances){
#define the covariances
A = diag(SmallDimension)
v = matrix(rnorm(SmallDimension),nrow = SmallDimension, ncol = 1)
A = A + spike*v%*%t(v)
rootA = sqrtm(A)
invA = solve(A)
invA = invA/tr(invA)
normA = norm(invA,"F")^2
B = diag(BigDimension)
v = matrix(rnorm(BigDimension),nrow = BigDimension, ncol = 1)
B = B + spike*v%*%t(v)
rootB = sqrtm(B)
invB = solve(B)
print(c("regularizer: ", j))
#for each covariance we will compute the estimate with fresh samples from the model a few times
for(i in 1:TrialsPerInstance){
#create the fresh samples
X = list(0*c(1:NumSamples))
dat = matrix(0, ncol = NumSamples, nrow = SmallDimension*BigDimension)
for(i in 1:NumSamples){
#create the data
X[[i]] = rootA%*%matrix(rnorm(SmallDimension*BigDimension,sd=1), nrow=SmallDimension, ncol=BigDimension)%*%rootB
#also create it for matlab format -_-
dat[,i] = X[[i]]
}
#trivial frobenius error
TrivialError = norm(invA - diag(SmallDimension)/SmallDimension,"F")^2 / normA
results$Trivial[j] = results$Trivial[j]+ TrivialError/(NumInstances*TrialsPerInstance)
#operator error
OpTrivialError = norm(invA - diag(SmallDimension)/SmallDimension,"I")^2
OpResults$Trivial[j] = OpResults$Trivial[j]+ OpTrivialError/(NumInstances*TrialsPerInstance)
#geodesic trivial
GeoTrivialError = GeodesicDistance(DetNorm(invA), diag(SmallDimension))
#GeoResults$Trivial[j] = GeoResults$Trivial[j] + GeoTrivialError/(NumInstances*TrialsPerInstance)
GeoResults$Trivial[j] = GeoResults$Trivial[j] + 1/(NumInstances*TrialsPerInstance)
#gemini
#set gemini penalties
GeminiRegFactor = 1*sqrt(log(SmallDimension)/BigDimension)
tic("geminiB")
out <- GeminiBmult(X, GeminiRegFactor*Regularizers[j], penalize.diagonal=FALSE)
toc()
GeminiEstimate = out$B.hat.inv
#calculate frobenius error
GeminiError = norm(invA - (GeminiEstimate/tr(GeminiEstimate)),"F")^2 / normA
results$Gemini[j] = results$Gemini[j]+ GeminiError/(NumInstances*TrialsPerInstance)
#operator error
OpGeminiError = norm(invA - (GeminiEstimate/tr(GeminiEstimate)),"I")^2
OpResults$Gemini[j] = OpResults$Gemini[j]+ OpGeminiError/(NumInstances*TrialsPerInstance)
#calculate geodesic error
GeoGeminiError = GeodesicDistance(DetNorm(invA), DetNorm(GeminiEstimate))^2/GeoTrivialError^2
GeoResults$Gemini[j] = GeoResults$Gemini[j] + GeoGeminiError/(NumInstances*TrialsPerInstance)
#regularized Sinkhorn
#set sinkhorn penalties
RegSinkFactor = 10
tic("regularized sinkhorn")
RegSinkEstimate = regsinkhorn(X,tol = .1*Regularizers[j], reg = Regularizers[j]*RegSinkFactor)[[1]]
toc()
#calculate frobenius
RegSinkError = norm(invA - (RegSinkEstimate/tr(RegSinkEstimate)),"F")^2 / normA
results$RegSink[j] = results$RegSink[j]+ RegSinkError/(NumInstances*TrialsPerInstance)
#operator error
OpSinkError = norm(invA - (RegSinkEstimate/tr(RegSinkEstimate)),"I")^2
OpResults$RegSink[j] = OpResults$RegSink[j]+ OpSinkError/(NumInstances*TrialsPerInstance)
#geodesic distance
GeoSinkError = GeodesicDistance(DetNorm(invA), DetNorm(RegSinkEstimate))^2/GeoTrivialError^2
GeoResults$RegSink[j] = GeoResults$RegSink[j] + GeoSinkError/(NumInstances*TrialsPerInstance)
#KGlasso
print(c("MatReg, ", MatReg))
setVariable(matlab, dat = dat)
evaluate(matlab,"[C,D] = KGL_R(dat,SmallDimension,BigDimension,NumSamples,MatReg,MatReg,10,.01);")
KGlassoEstimate = getVariable(matlab,"C")$C
KGlassoError = norm(invA - (KGlassoEstimate/tr(KGlassoEstimate)),"F")^2 / normA
#print(c("Glasso Error: ",KGlassoError))
results$KGlasso[j] = results$KGlasso[j]+ KGlassoError/(NumInstances*TrialsPerInstance)
#operator error
OpKGlassoError = norm(invA - (KGlassoEstimate/tr(KGlassoEstimate)),"I")^2
OpResults$KGlasso[j] = OpResults$KGlasso[j]+ OpKGlassoError/(NumInstances*TrialsPerInstance)
#geodesic distance
GeoKGlassoError = GeodesicDistance(DetNorm(invA), DetNorm(KGlassoEstimate))^2/GeoTrivialError^2
GeoResults$KGlasso[j] = GeoResults$KGlasso[j] + GeoKGlassoError/(NumInstances*TrialsPerInstance)
}
}
}
output<- list(Results = results,OpResults = OpResults, GeoResults = GeoResults)
}
ans = SpikedComparison(10,10,2,RegMin=-2,RegMax = 2,NumInstances =1, TrialsPerInstance  = 1, RegStride = .5)
#making the plots even nicer
library(gridExtra)
lp1=SimplePlot(ans$GeoResults)
lp1 = lp1 + ggtitle("Error in Geodesic distance") #cool way to title on the fly :)
lp2=SimplePlot(ans$OpResults)
lp2 = lp2 + ggtitle("Error in operator norm")
lp3=SimplePlot(ans$Results)
lp3 = lp3 + ggtitle("Error in Frobenius norm")
p = grid.arrange(lp1,lp2,lp3,nrow=1)
p
#pdf("25-50-spiked-frob.pdf")
#lp
#dev.off()
#lp
